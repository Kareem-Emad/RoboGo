"use strict";const validTypes=["number","Boolean","string","Color","Vertex","Move","List","MultiLineList","Alternative"];class Color{constructor(t){if("string"!=typeof t)throw"Parameter is not a color value";"w"!==(t=t.toLowerCase())&&"white"!==t&&"b"!==t&&"black"!==t||(this.color=t)}toString(){return this.color}}class Vertex{constructor(t){if("string"!=typeof t)throw"Invalid Vertex Value";if("pass"!==t){if(t.length>3)throw"invalid vertex value";if("i"===t[0]||"I"===t[0])throw"invalid vertex value";let e=t.slice(1,3);if(!isNaN(e)&&e>25)throw"Invalid vertex value: protocol doesn't support boards larger than 25x25";let n=t.charCodeAt(0),r=26;if(n>=65&&n<=90?r=n[0]<73?n-64:n-65:n>=97&&n<=122&&(r=n<105?n-96:n-97),r>25)throw"Invalid vertex value: protocol doesn't support boards larger than 25x25"}this.vertex=t}toString(){return this.vertex}}class Move{constructor(t){if("string"!=typeof t)throw"Invalid Move must be string containing a Color and a Vertex separated by a space";{if(2!==(t=t.split(" ")).length)throw"Invalid Move must be string containing a Color and a Vertex separated by a space";let e=null,n=null;try{e=new Color(t[0]),n=new Vertex(t[1])}catch(t){throw"Invalid Move must be string containing a Color and a Vertex separated by a space"}this.move=`${e.toString()} ${n.toString()}`}}toString(){return this.move}}class List{constructor(t){if(!validTypes.includes(t))throw"Invalid List type";this.type=t,this.items=[]}append(t){if(typeof t!==this.type)throw"Invalid List Type";this.items.push(t)}appendAll(t){for(index in t){if(typeof t[index]!==this.type)throw"Invalid List Type";this.items.push(t[index])}}toString(){let t="";for(let e=0;e<this.items.length;e++)""===t?t=this.items[e].toString():t+=" "+this.items[e].toString();return t}apply(t){for(let e in this.items)this.items[e]=t(this.items[e])}}class MultiLineList{constructor(t){if(!validTypes.includes(t))throw"Invalid MultiLineList type";this.type=t,this.items=[]}append(t){if(typeof t!==this.type)throw"Invalid List Type";this.items.push(t)}appendAll(t){for(index in t){if(typeof t[index]!==this.type)throw"Invalid List Type";this.items.push(t[index])}}toString(){let t="";for(let e=0;e<this.items.length;e++)t+=this.items[e].toString()+"\n";return t}apply(t){for(let e in this.items)this.items[e]=t(this.items[e])}}let getArrowFunctionArgList=t=>{let e=t.toString().split("\n")[0].match(/\((.*?)\)/)[1].replace(/ /g,"").split(",");return e=1===e.length&&""===e[0]?[]:e},arraysMatch=(t,e)=>{if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0},toFloat=t=>{let e=parseFloat(t,10);if(e.toString()!==t)throw"not a float value";return e},toInt=t=>{let e=parseInt(t,10);if(e.toString()!==t)throw"not an integer value";return e},isInt=t=>"number"==typeof t&&t===parseInt(t,10)&&parseInt(t,10)>=0;const commandsList=["protocol_version","name","version","known_command","list_commands","quit","boardsize","clear_board","komi","fixed_handicap","place_free_handicap","set_free_handicap","play","genmove","undo","time_settings","time_left","final_score","final_status_list","loadsgf","reg_genmove","showboard"];let protocol_version=()=>2,name=()=>{let t=entities.List("string");return t.append("Go"),t.append("Slayer"),t},version=()=>{let t=List("string");return t.append("1.0.0"),t},known_command=t=>commandsList.includes(t),list_commands=()=>{let t=MultiLineList("string");return t.appendAll(commandsList),t},quit=()=>{},boardsize=t=>{try{t=toInt(t)}catch(t){throw`Invalid board size is ${t}`}if(t>25)throw"Invalid board size protocol doesn't support boards bigger than 25x25"},clear_board=()=>{},komi=t=>{try{t=toFloat(t)}catch(t){throw`Invalid Komi is ${t}`}},fixed_handicap=t=>{try{t=toInt(t)}catch(t){throw`Invalid number of stones is ${t}`}return List("Vertex")},place_free_handicap=t=>{try{t=toInt(t)}catch(t){throw`Invalid number of stones is ${t}`}return List("Vertex")},set_free_handicap=t=>{if(!List.prototype.isPrototypeOf(t)||"Vertex"!==t.type)throw"Invalid List of vertices"},play=t=>{t=new Move(t.toString())},genmove=t=>{t=new Color(t.toString());return"resign"},undo=()=>{},time_settings=(t,e,n)=>{try{t=toInt(t),e=toInt(e),n=toInt(n)}catch(t){throw"Invalid parameters must be integer values"}},time_left=(t,e,n)=>{try{e=toInt(e),n=toInt(n)}catch(t){throw"Invalid parameters must be integer values"}t=new Color(t.toString())},final_score=()=>{return""},final_status_list=t=>{if("string"!=typeof t)throw"invalid status value";return MultiLineList("List")},loadsgf=(t,e)=>{if("string"!=typeof t)throw"Invalid filename";try{e=toInt(e)}catch(t){throw`Invalid move number is ${t}`}},reg_genmove=t=>{if("Color"!=typeof t)throw"Invalid Argument: provided color is not of type color";return"resign"},showboard=()=>{return MultiLineList("List")},commands={protocol_version:protocol_version,name:name,version:version,known_command:known_command,list_commands:list_commands,quit:quit,boardsize:boardsize,clear_board:clear_board,komi:komi,fixed_handicap:fixed_handicap,place_free_handicap:place_free_handicap,set_free_handicap:set_free_handicap,play:play,genmove:genmove,undo:undo,time_settings:time_settings,time_left:time_left,final_score:final_score,final_status_list:final_status_list,loadsgf:loadsgf,reg_genmove:reg_genmove,showboard:showboard},makeRequest=(t,e,n=null)=>{if(!commandsList.includes(t))throw"Invalid Argument: command doesn't exist";if(null!==n&&!isInt(n))throw"Invalid Argument: id must be an integer";let r=getArrowFunctionArgList(commands[t]);if(!arraysMatch(r,Object.keys(e)))throw`Invalid Argument: ${t} arguments list should be [${r}], however, [${Object.keys(e)}] was provided`;let o="";null!==n&&(o+=`${n} `),o+=t;let i=Object.values(e);for(let t in i)o+=` ${i[t].toString()}`;return o+="\n"},parseRequest=t=>{if("string"!=typeof t)throw`request must be string, however ${typeof t} was passed`;t=(t=t.replace(/\r?\n|\r/g,"")).split(" ");let e=null,n=null,r=null;return isInt(t[0])?(e=parseInt(t[0],10),n=t[1],r=t.slice(2)):(n=t[1],r=t.slice(2)),{id:e,command:n,args:r}},takeRequest=t=>{let e=null;try{e=parseRequest(t)}catch(t){return`? ${t}\n\n`}let n=e.id,r=e.command,o=e.args,i=null!==n?`?${n}`:"?",s=null!==n?`=${n}`:"=";if(!commandsList.includes(r))return`${i} command doesn't exist\n\n`;if(getArrowFunctionArgList(commands[r]).length===o.length)return`${i} ${r} arguments doesn't match\n\n`;try{return`${s} ${commands[r](...o).toString()}\n\n`}catch(t){return`? ${t}\n\n`}},socket=new WebSocket("ws://localhost:9002");socket.onopen=function(t){alert("[open] Connection established")},socket.onmessage=function(t){alert(`[message] Data received from server: ${t.data}`)},socket.onclose=function(t){t.wasClean?alert(`[close] Connection closed cleanly, code=${t.code} reason=${t.reason}`):alert("[close] Connection died")},socket.onerror=function(t){alert(`[error] ${t.message}`)};var c=document.getElementById("go-canvas"),ctx=c.getContext("2d"),black=document.getElementById("black"),white=document.getElementById("white");const startOffset=20,arraySize=18,endOffset=c.width-20,step=(c.width-40)/18;var board=new Array(19).fill(0).map(()=>new Array(19).fill(0));const drawBoard=()=>{for(let t=20;t<=endOffset;t+=step)ctx.moveTo(t,20),ctx.lineTo(t,endOffset),ctx.stroke();for(let t=20;t<=endOffset;t+=step)ctx.moveTo(20,t),ctx.lineTo(endOffset,t),ctx.stroke()},drawAllPieces=()=>{let t=0;for(let e=20-step/2;e<endOffset;e+=step){let n=0;for(let r=20-step/2;r<endOffset;r+=step)board[t][n]&&("w"==board[t][n]?ctx.drawImage(white,e,r,step,step):ctx.drawImage(black,e,r,step,step)),n++;t++}};board[0][0]="w",board[7][12]="w",board[9][13]="w",board[8][16]="b",board[7][17]="b",board[5][16]="b",board[18][18]="b",drawBoard(),drawAllPieces();