"use strict";const validTypes=["number","boolean","string","Color","Vertex","Move","List","MultiLineList","Alternative"];let whichClass=t=>"number"==typeof t||"boolean"==typeof t||"string"==typeof t?typeof t:Color.prototype.isPrototypeOf(t)?"Color":Vertex.prototype.isPrototypeOf(t)?"Vertex":Move.prototype.isPrototypeOf(t)?"Move":List.prototype.isPrototypeOf(t)?"List":MultiLineList.prototype.isPrototypeOf(t)?"MultiLineList":void 0;class Color{constructor(t){if("string"!=typeof t)throw"Parameter is not a color value";if("w"===(t=t.toLowerCase())||"white"===t)this.color="w";else{if("b"!==t&&"black"!==t)throw"Parameter is not a color value";this.color="b"}}toString(){return this.color}}class Vertex{constructor(t){if("string"!=typeof t)throw"Invalid Vertex Value";if("pass"!==t){if(t.length>3)throw"invalid vertex value";if("i"===t[0]||"I"===t[0])throw"invalid vertex value";let e=t.slice(1,3);if(!(!isNaN(e)&&e>0&&e<25))throw"Invalid vertex value: protocol doesn't support boards larger than 25x25";let n=t.charCodeAt(0),o=26;if(n>=65&&n<=90?o=n[0]<73?n-64:n-65:n>=97&&n<=122&&(o=n<105?n-96:n-97),o>25)throw"Invalid vertex value: protocol doesn't support boards larger than 25x25"}this.vertex=t}static indecies(t){if(!Vertex.prototype.isPrototypeOf(t))throw"Invalid Vertex Value";let e=t.toString()[0],n=parseInt(t.toString().slice(1,3)),o=e.charCodeAt(0),r=0;return o>=65&&o<=90?r=o[0]<73?o-64:o-65:o>=97&&o<=122&&(r=o<105?o-96:o-97),{row:n,column:r}}toString(){return this.vertex}}class Move{constructor(t){if("string"!=typeof t)throw"Invalid Move must be string containing a Color and a Vertex separated by a space";{if(2!==(t=t.split(" ")).length)throw"Invalid Move must be string containing a Color and a Vertex separated by a space";let e=null,n=null;try{e=new Color(t[0]),n=new Vertex(t[1])}catch(t){throw"Invalid Move must be string containing a Color and a Vertex separated by a space"}this.move=`${e.toString()} ${n.toString()}`}}toString(){return this.move}}class List{constructor(t){if(!validTypes.includes(t))throw"Invalid List type";this.type=t,this.items=[]}append(t){if(whichClass(t)!==this.type)throw"Invalid List Type";this.items.push(t)}appendAll(t){for(index in t){if(whichClass(t[index])!==this.type)throw"Invalid List Type";this.items.push(t[index])}}toString(){let t="";for(let e=0;e<this.items.length;e++)""===t?t=this.items[e].toString():t+=" "+this.items[e].toString();return t}apply(t){for(let e in this.items)this.items[e]=t(this.items[e])}}class MultiLineList{constructor(t){if(!validTypes.includes(t))throw"Invalid MultiLineList type";this.type=t,this.items=[]}append(t){if(whichClass(t)!==this.type)throw"Invalid List Type";this.items.push(t)}appendAll(t){for(index in t){if(whichClass(t[index])!==this.type)throw"Invalid List Type";this.items.push(t[index])}}toString(){let t="";for(let e=0;e<this.items.length;e++)t+=this.items[e].toString()+"\n";return t}apply(t){for(let e in this.items)this.items[e]=t(this.items[e])}}let socket=new WebSocket("ws://localhost:9002");Object.prototype.watch||Object.defineProperty(Object.prototype,"watch",{enumerable:!1,configurable:!0,writable:!1,value:function(t,e){var n=this[t],o=n;delete this[t]&&Object.defineProperty(this,t,{get:function(){return o},set:function(r){return n=o,o=e.call(this,t,n,r)},enumerable:!0,configurable:!0})}}),Object.prototype.unwatch||Object.defineProperty(Object.prototype,"unwatch",{enumerable:!1,configurable:!0,writable:!1,value:function(t){var e=this[t];delete this[t],this[t]=e}});let getArrowFunctionArgList=t=>{let e=t.toString().split("\n")[0].match(/\((.*?)\)/)[1].replace(/ /g,"").split(",");return e=1===e.length&&""===e[0]?[]:e,e},arraysMatch=(t,e)=>{if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0},toFloat=t=>{let e=parseFloat(t,10);if(e.toString()!==t)throw"not a float value";return e},toInt=t=>{let e=parseInt(t,10);if(e.toString()!==t)throw"not an integer value";return e},isInt=t=>"number"==typeof t&&t===parseInt(t,10)&&parseInt(t,10)>=0;const commandsList=["protocol_version","name","version","known_command","list_commands","quit","boardsize","clear_board","komi","fixed_handicap","place_free_handicap","set_free_handicap","play","genmove","undo","time_settings","time_left","final_score","final_status_list","loadsgf","reg_genmove","showboard"];let protocol_version=()=>2,name=()=>{let t=entities.List("string");return t.append("Go"),t.append("Slayer"),t},version=()=>{let t=List("string");return t.append("1.0.0"),t},known_command=t=>commandsList.includes(t),list_commands=()=>{let t=MultiLineList("string");return t.appendAll(commandsList),t},quit=()=>{},boardsize=t=>{try{t=toInt(t)}catch(t){throw`Invalid board size is ${t}`}if(t>25)throw"Invalid board size protocol doesn't support boards bigger than 25x25"},clear_board=()=>{},komi=t=>{try{t=toFloat(t)}catch(t){throw`Invalid Komi is ${t}`}},fixed_handicap=t=>{try{t=toInt(t)}catch(t){throw`Invalid number of stones is ${t}`}return List("Vertex")},place_free_handicap=t=>{try{t=toInt(t)}catch(t){throw`Invalid number of stones is ${t}`}return List("Vertex")},set_free_handicap=t=>{if(!List.prototype.isPrototypeOf(t)||"Vertex"!==t.type)throw"Invalid List of vertices"},play=t=>{t=new Move(t.toString());let e=new Color(t.toString().split(" ")[0]).toString(),n=Vertex.indecies(new Vertex(t.toString().split(" ")[1])),o=arraySize-(n.row-1),r=n.column-1;addPiece(r,o,e)},genmoveId=0,genmove=t=>{let e=new Color(t.toString());return currentPlayer=e.toString(),allowMove=!0,"break"};pieceLocation.watch("location",(t,e,n)=>{allowMove=!1,2!==n.length&&socket.send(`=${genmoveId} resign\n\n`);let o=(arraySize-(n[1]-1)).toString();o=1==o.length?`0${o}`:o;let r=n[0]+1<9?n[0]+97:n[0]+98,i=String.fromCharCode(r),s=new Vertex(`${i}${o}`);socket.send(`=${genmoveId} ${s.toString()}\n\n`)});let undo=()=>{},time_settings=(t,e,n)=>{try{t=toInt(t),e=toInt(e),n=toInt(n)}catch(t){throw"Invalid parameters must be integer values"}},time_left=(t,e,n)=>{try{e=toInt(e),n=toInt(n)}catch(t){throw"Invalid parameters must be integer values"}t=new Color(t.toString())},final_score=()=>{return""},final_status_list=t=>{if("string"!=typeof t)throw"invalid status value";return MultiLineList("List")},loadsgf=(t,e)=>{if("string"!=typeof t)throw"Invalid filename";try{e=toInt(e)}catch(t){throw`Invalid move number is ${t}`}},reg_genmove=t=>{if("Color"!=typeof t)throw"Invalid Argument: provided color is not of type color";return"resign"},showboard=()=>{return MultiLineList("List")},commands={protocol_version:protocol_version,name:name,version:version,known_command:known_command,list_commands:list_commands,quit:quit,boardsize:boardsize,clear_board:clear_board,komi:komi,fixed_handicap:fixed_handicap,place_free_handicap:place_free_handicap,set_free_handicap:set_free_handicap,play:play,genmove:genmove,undo:undo,time_settings:time_settings,time_left:time_left,final_score:final_score,final_status_list:final_status_list,loadsgf:loadsgf,reg_genmove:reg_genmove,showboard:showboard},makeRequest=(t,e,n=null)=>{if(!commandsList.includes(t))throw"Invalid Argument: command doesn't exist";if(null!==n&&!isInt(n))throw"Invalid Argument: id must be an integer";let o=getArrowFunctionArgList(commands[t]);if(!arraysMatch(o,Object.keys(e)))throw`Invalid Argument: ${t} arguments list should be [${o}], however, [${Object.keys(e)}] was provided`;let r="";null!==n&&(r+=`${n} `),r+=t;let i=Object.values(e);for(let t in i)r+=` ${i[t].toString()}`;return r+="\n",r},parseRequest=t=>{if("string"!=typeof t)throw`request must be string, however ${typeof t} was passed`;t=(t=t.replace(/\r?\n|\r/g,"")).split(" ");let e=null,n=null,o=null;return parseInt(t[0],10).toString()===t[0]?(e=toInt(t[0]),n=t[1],o=t.slice(2)):(n=t[0],o=t.slice(1)),{id:e,command:n,args:o}},takeRequest=t=>{let e=null;try{e=parseRequest(t)}catch(t){return`? ${t}\n\n`}let n=e.id,o=e.command,r=e.args,i=null!==n?`?${n}`:"?",s=null!==n?`=${n}`:"=";if(!commandsList.includes(o))return`${i} command doesn't exist\n\n`;if("play"===o&&(r=[r.join(" ")]),getArrowFunctionArgList(commands[o]).length!==r.length)return`${i} ${o} arguments doesn't match\n\n`;try{let t=commands[o](...r);return"break"===t?(genmoveId=null==n?"":n.toString(),"break"):void 0!==t?`${s} ${t.toString()}\n\n`:`${s}\n\n`}catch(t){return`? ${t}\n\n`}};socket.onopen=function(t){alert("[open] Connection established")},socket.onmessage=function(t){let e=takeRequest(t.data);"break"!==e&&socket.send(e)},socket.onclose=function(t){t.wasClean?alert(`[close] Connection closed cleanly, code=${t.code} reason=${t.reason}`):alert("[close] Connection died")},socket.onerror=function(t){alert(`[error] ${t.message}`)};